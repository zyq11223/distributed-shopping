## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 超卖现象
我们考虑这样一种情形，如某个参与被秒杀的商品目前库存数量为1，此时有两个用户同时购买该商品(减库存操作)。用户1提交订单后该商品的库存数量修改为0，此时当用户2不知情的情况下，提交了订单，该商品库存数量被修改为-1，显然用户2不可能秒杀成功，这就是在电商领域常见的超卖现象。<br>
![输入图片说明](https://images.gitee.com/uploads/images/2018/1014/234928_7efb1f3e_1648495.png "2.png")<br>
原因：数据库底层的读写操作可同时进行，写操作默认有隐式锁，而读操作默认是不带锁的，故两个用户可同时查看到目前库存数量为1。<br>
解决方案：<br>
(1)对读操作加显示锁，在SQL语言层表现为select ... for update 。这样一来，一个用户在读取库存时，其他用户只能排队等待读取了，然而当并发量很高时，系统效率会较大幅度下降，为此可使用如下解决方法（见解决方案(2)）<br>
(2)我们需要在SQL语言层面上添加一个判断条件，判断库存数量是否大于0。虽然在更新库存时，数据库会加锁，不会出现两个线程同时更新同一条记录的情况，但这是不够的。我们再考虑如下情形。<br>
 
某商品库存数量为10，某个用户通过某种手段抓取了秒杀接口，同时发出两个请求req1与req2，两个请求同时按照如下的逻辑检查均没问题，也就是说一个用户可以秒杀两件商品。<br>
![输入图片说明](https://images.gitee.com/uploads/images/2018/1014/235610_87221f6c_1648495.png "3.png")<br>

解决方案：<br>
(1)在数据库中的秒杀订单表中的nickname字段上加个唯一索引。因为我们的限制是对于同一参与被秒杀的商品，用户只能秒杀一个，加上唯一索引后，第一个请求req1可以成功地修改了数据库，生成订单。而第二个请求req2插入数据库时由于两个请求的商品id、nickname相同而报错，事务回滚。<br>



